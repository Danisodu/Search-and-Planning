;;;; Author(s): Group 8


(in-package :user)

;-------------------------------------------------
;-----------------------IMPORTS-------------------
;-------------------------------------------------
(load "C:/Users/X541U/OneDrive/IST/Search-and-Planning/procura.lisp")


;-------------------------------------------------
;---------------------CONSTANTS-------------------
;-------------------------------------------------
(defconstant max-shift 480)
(defconstant max-time-til-lunch 240)
(defconstant drive-duration 40)
(defconstant eat-duration 40)


;------------------------------------------------
;----------------------STRUCTS-------------------
;------------------------------------------------
(defstruct shift
  tasks
  time-used)

(defstruct state
  shifts
  to-assign-tasks
  heuristic-value)


;------------------------------------------------
;---------------------HEURISTICS-----------------
;------------------------------------------------
 ;;;calc-empty-spaces: shift -> inteiro
;; Receives a shift (sorted) and returns the sum of empty spaces between tasks
(defun calc-sum-empty-spaces(shift)
    (let ((sum-empty-spaces 0) 
        (tasks (shift-tasks shift))
        (current)
        (next)
        (space)) 
     
        ;When using the heuristic this will never happen
        (if (eq tasks nil) (return-from calc-sum-empty-spaces 0))
        
        ;If only one element there can not be empty spaces
        (if (eq (list-length tasks) 1) (return-from calc-sum-empty-spaces 0))
        
        ;Calculate consecutive tasks empty space
        (loop for i from 0 to (- (list-length tasks) 1) do 
            (setf current (nth i tasks))
            (setf next (nth (+ i 1) tasks))
            (if next (progn
                            (setf space (empty-space-two-tasks current next))
                            (incf sum-empty-spaces space))))
                            
        sum-empty-spaces))


;;;empty-spaces-heuristic: state -> integer
;; Calculates the sum of all empty time spaces between consecutive tasks in all state shifts
(defun empty-spaces-heuristic (state)
    (let(
        (shifts (state-shifts state))
        (sum-all-shifts 0))
        
        (dolist (shift shifts)
            (incf sum-all-shifts (calc-sum-empty-spaces shift)))
    )
)
        
;-------------------------------------------
;------------Shifts Number Heuristic--------
;-------------------------------------------
(defun shifts-number-heuristic (state)
    (let(
        (shifts (state-shifts state)))
        
        (list-length shifts)))
        
        
        
;-------------------------------------------
;------------Spacial Consecutive Tasks------
;-------------------------------------------
;;;spacial-consecutive-tasks? task x task -> boolean
;; Check if two tasks are spacial consecutive, ie, if t1 ends where t2 starts      
(defun spacial-consecutive-tasks?(t1 t2)
    (equal (nth 1 t1) (nth 0 t2) )
)

(defun starts-in-L1? (shift)
    (let* ( (tasks (shift-tasks shift))
            (first-task (first tasks)))
            
        (equal (nth 0 first-task) 'L1)))

        
(defun ends-in-L1? (shift)
    (let* ( (tasks (shift-tasks shift))
            (last-task (nth (- (list-length tasks) 1) tasks)))
    (equal (nth 1 last-task) 'L1)))
    
    

;;; Shift -> integer
;; Calculates the number of all no-service trips needed to guarantee spacial continuity in one shift
(defun calc-no-service-trips(shift)
    (let ((sum-no-services-trips 0) 
        (tasks (shift-tasks shift))
        (current)
        (next)
        ) 
        
        ;Empty list has no trips at all, not really going to happen tho...
        (if (eq tasks nil) (return-from calc-no-service-trips 0))
        
        ;Check if trip to start in L1 is needed
        (if (not (starts-in-L1? shift)) (incf sum-no-services-trips 1))
        
        ;Check if trip to end in L1 is needed
        (if (not (ends-in-L1? shift)) (incf sum-no-services-trips 1))

        ;Calculate needed trips beetwen tasks
        (loop for i from 0 to (- (list-length tasks) 1) do 
            (setf current (nth i tasks))
            (setf next (nth (+ i 1) tasks))
            (if next 
                (if (not (spacial-consecutive-tasks? current next)) (incf sum-no-services-trips 1))))
                            
        sum-no-services-trips))


;;;empty-spaces-heuristic: state -> integer
;; Calculates the sum of all empty time spaces between consecutive tasks in all state shifts
(defun consecutive-tasks-heuristic (state)
    (let(
        (shifts (state-shifts state))
        (sum-all-shifts 0))
        
        (dolist (shift shifts)
            (incf sum-all-shifts (calc-no-service-trips shift)))
    )
)


;------------------------------------------------
;--------------------ALGORITHMS------------------
;------------------------------------------------
(defun sort-by-heuristic-value (states)
  (loop for state in states do
        (setf (state-heuristic-value state) (shifts-number-heuristic state)))

  (sort states #'< :key #'state-heuristic-value)
)

(defun ILDS-iteration (state discrepancies depth)
  (let ((sucessors (sort-by-heuristic-value (sucessors (copy-structure state)))))
  (print "current state")
  (print state)
  (print "sucessores")
  (print sucessors)
 
    (if (is-goal state)
        (if (= discrepancies 0)
            (return-from ILDS-iteration state)
          (return-from ilds-iteration nil)))

    (if (and (> discrepancies 0)
             (> (length sucessors) 1))
        (ILDS-iteration (nth 1 sucessors) (1- discrepancies) (1- depth)))
    (if (> depth discrepancies)
        (ILDS-iteration (car sucessors) discrepancies (1- depth)))
))

(defun ILDS (problem)
  (let ((initial-state (problema-estado-inicial problem))
        (solution '())
        (sol)
        (discrepancies 0)
        (depth))
    (setf depth (length (state-to-assign-tasks initial-state)))

    (loop for k from 0 to depth do
          (print k)
          (setf sol (ILDS-iteration initial-state discrepancies depth))

          (if (not (null sol))
              (setf solution (nconc solution (list sol))))

          (incf discrepancies))
    (print "acabou")

    (return-from ILDS solution))
)


;------------------------------------------------
;----------------------FUNCS---------------------
;------------------------------------------------
(defun add-drive-duration? (origin destination end-time)
  (if (not (eq origin destination))
      (setf end-time (+ end-time drive-duration)))
  (return-from add-drive-duration? end-time))

(defun calc-shift-time (tasks)
  (let ((last-task (nth (1- (length tasks)) tasks))
        (start-time (nth 2 (car tasks))))
    (if (not (equalp (nth 0 (car tasks)) 'L1))
        (setf start-time (- start-time drive-duration)))
    (- (add-drive-duration? (nth 1 last-task) 'L1 (nth 3 last-task))
       start-time)))

(defun create-shift (tasks)
   (make-shift :tasks tasks
               :time-used (calc-shift-time tasks)))

(defun create-state (shifts toAssignTasks)
  (make-state :shifts shifts
              :to-assign-tasks toAssignTasks))

;(defun copy-state(state)
;  (create-state (state-shifts state) (state-to-assign-tasks state))
;)

;(defun copy-shift(shift)
;  (create-shift (shift-tasks shift))
;)

(defun insert-task-in-position (position task tasks)
  (let((first-sub-seq (subseq tasks
                              0
                              position)))
    (if (null first-sub-seq)
        (setf first-sub-seq '()))
  (nconc (nconc first-sub-seq
                (list task))
         (nthcdr position tasks))))

(defun add-task-to-shift (position task shift)
  (let ((new-tasks-list (insert-task-in-position position
                                                 task
                                                 (shift-tasks shift))))
  (setf (shift-tasks shift) new-tasks-list
        (shift-time-used shift) (calc-shift-time new-tasks-list))))

(defun empty-space-two-tasks (t1 t2)
  (- (nth 2 t2)
     (add-drive-duration? (nth 1 t1)
                          (nth 0 t2)
                          (nth 3 t1)))
)

(defun calc-1st-empty-space(last-task)
  (let((1st-empty-space-start-time (- (nth 3 last-task)
                    max-shift))
       (1st-empty-space (list 'L1 'L1 nil)))
  (if (< 1st-empty-space-start-time 0)
      (setf 1st-empty-space-start-time 0))
    (nconc 1st-empty-space
           (list 1st-empty-space-start-time))))

(defun has-space-to-lunch (tasks)
  (let ((first-task (nth 0 tasks))
        (tasks (cons (calc-1st-empty-space (nth (1- (length tasks)) tasks))
                     tasks))
        (pos 0)
        (current)
        (next)
        (shift-time 0))
    (loop while (and (<= pos
                        (- (length tasks) 2))
                     (<= shift-time max-time-til-lunch)) do
        (setf current (nth pos tasks)
              next (nth (1+ pos) tasks)
              pos (1+ pos))
        (setf shift-time (calc-shift-time (list first-task
                                                next)))
        (if (>= (empty-space-two-tasks current
                                       next)
                eat-duration)
            (return-from has-space-to-lunch 'T)))))

;;;list can't be empty
;;VER LOGO SE PARA ESSE EMPTY SPACE SE DÁ
(defun calc-empty-spaces (tasks)
  (let ((empty-spaces '())
        (last-task (nth (1- (length tasks)) tasks))
        (first-task (nth 0 tasks))
        (current)
        (next))
    (setf empty-spaces (list (list (calc-1st-empty-space last-task)
                                    first-task)))
    (loop for i from 0 to (- (length tasks) 2) do
          (setf current (nth i tasks)
                next (nth (1+ i) tasks))
          (setf empty-spaces (nconc empty-spaces
                                    (list (list current
                                          next)))))
    (nconc empty-spaces
           (list (list last-task
                 (list 'L1 'L1 (+ (nth 2 first-task) max-shift) nil))))))

(defun can-lunch (shift)
  (let ((correct 'T))
    (if (> (shift-time-used shift)
           max-time-til-lunch)
        (setf correct (has-space-to-lunch (shift-tasks shift))))
    (return-from can-lunch correct)))

(defun is-intersected (new-task other-task1 other-task2)
  (let ((new-task-start-time (nth 2 new-task))
        (new-task-end-time (nth 3 new-task))
        (new-task-origin (nth 0 new-task))
        (new-task-destination (nth 1 new-task))
        (other1-task-end-time (nth 3 other-task1))
        (other1-task-destination (nth 1 other-task1))
        (other2-task-origin (nth 0 other-task2))
        (other2-task-start-time (nth 2 other-task2)))
    (setf other1-task-end-time (add-drive-duration? new-task-origin
                                                    other1-task-destination
                                                    other1-task-end-time)
          new-task-end-time (add-drive-duration? other2-task-origin
                                                 new-task-destination
                                                 new-task-end-time))
      (or (> other1-task-end-time new-task-start-time)
          (> new-task-end-time other2-task-start-time))))

(defun find-position (new-task tasks)
  (let ((empty-spaces (calc-empty-spaces tasks)))
    (loop for empty-space in empty-spaces and pos from 0 do
          (multiple-value-bind(intersected) (is-intersected new-task
                                                            (nth 0 empty-space)
                                                            (nth 1 empty-space))
            (if (not intersected)
                (return-from find-position pos))))
  (return-from find-position -1)))

(defun update-sucessors-lst(shifts state sucessors)
  (setf (state-shifts state) shifts)
  (nconc sucessors (list state)))

(defun sucessors (state)
 (let ((next-task (pop (state-to-assign-tasks state)))
        (position)
        (current-shift)
        (shifts (state-shifts state))
        (shfts)
        (stte)
        (last-shift)
        (sucessors '()))
	
    ;added to check if all nodes are already expanded, if yes return nil
   (if (null next-task) (return-from sucessors nil))	
   
   ;ATE QUANTOS SUCESSORES????????????
   (loop for pos from 0 to (1- (length shifts)) do
         (setf current-shift (copy-structure (nth pos shifts))
                shfts (copy-list shifts)
                stte (copy-state state))
         (setf position (find-position next-task
                                        (shift-tasks current-shift)))
         (if (>= position 0)
             (progn
               (add-task-to-shift position
                                  next-task
                                  current-shift)
               (if (can-lunch current-shift)
                   (progn
                     (setf (nth pos shfts) current-shift)
                     (setf sucessors (update-sucessors-lst shfts stte sucessors)))))))

    ;if it doesn't fit anywhere then a new shift will be created
    (if (= (length sucessors) 0)
        (progn
          (setf last-shift (create-shift (list next-task)))
          (if (can-lunch last-shift)
              (update-sucessors-lst (nconc shifts
                                           (list last-shift))
                                    state
                                    sucessors))))))
                              
;;;calculate-state-cost: state -> integer
;; Receives a state and return the cost of that state, based on the time of each shift
(defun calculate-state-cost (state)
    (let ((shifts (state-shifts state))
          (shift-time)
          (sum-all-shifts 0)
         )
        (dolist (shift shifts)
            (print shift)
            (setf shift-time (shift-time-used shift))
            (if (< shift-time (* 6 60)) (setf shift-time (* 6 60))) ;if less than 6h its considered 6h used
            (incf sum-all-shifts shift-time)
         )
        
        sum-all-shifts
    )
)

(defun is-goal (state)
  (eq (length (state-to-assign-tasks state)) 0))

(defun equality (s1 s2)
  (equalp s1 s2))

(defun faz-afetacao (toAssignTasks strategy)
 (let ((solution nil)
       (problem (cria-problema (create-state '() toAssignTasks)
                               (list #'sucessors)
                               :objectivo? #'is-goal
                               :estado= #'equality)))

       (cond ((equal strategy "melhor.abordagem") 
              )
             ((equal strategy "a*.melhor.heuristica") 
              )
             ((equal strategy "a*.melhor.heuristica.alternativa") 
              ;(setf (problema-heuristica problem) "")
              (set solution "(car (procura problem strategy))")
              )
             ((equal strategy "sondagem.iterativa") 
              )
             ((equal strategy "ILDS") 
              (setf solution (ILDS problem))
              )
             ((equal strategy "abordagem.alternativa") 
              )
       )
 solution))
