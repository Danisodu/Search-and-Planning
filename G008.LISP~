;;;; Author(s): Group 8

;;;;IMPORTS


;;;; CONSTANTS
(defconstant max-shift 480)
(defconstant max-time-til-lunch 240)
(defconstant drive-duration 40)
(defconstant eat-duration 40)


;;;; STRUCTS
(defstruct shift
  tasks
  time-used
  empty-space
  meal-taken)

(defstruct state
  shifts
  to-assign-tasks)


;;;; FUNCS
(defun task-time(task)
  (- (nth 3 task) (nth 2 task)))

(defun insert-task(position task tasks)
  (return-from insert-task (cons (cons (subseq tasks 0 position) task)
                                 (nthcdr position tasks))))
  
(defun calc-empty-spaces(task shift))

(defun add-drive-duration?(origin destination end-time)
  (if (/= origin destination)
      (setf end-time (+ end-time drive-duration)))
  (return-from add-drive-duration end-time))

(defun is-intersected(new-task prev-task)
  (let((new-task-start-time (nth 2 new-task))
       (new-task-end-time (nth 3 new-task))
       (new-task-origin (nth 0 new-task))
       (new-task-destination (nth 1 new-task))                    
       (prev-task-start-time (nth 2 prev-task))
       (prev-task-end-time (nth 3 prev-task))
       (prev-task-origin (nth 0 prev-task))
       (prev-task-destination (nth 1 prev-task))
       (further-start nil)
       (closer-end nil))
    (if (< new-task-start-time prev-task-start-time)
        (setf closer-end (add-drive-duration? new-task-destination prev-task-origin new-task-end-time)
              further-start prev-task-start-time)
      (setf closer-end (add-drive-duration? prev-task-destination new-task-origin prev-task-end-time)
            further-start new-task-start-time))
    (return-from is-intersected (> closer-end further-start))))

(defun calc-intersection (new-task tasks)
  ;(let((possible-positions '())
  (loop for task in tasks do
        (if (is-intersected new-task task)
            (return-from calc-intersection 'T)))
  (return-from calc-intersection nil))

(defun check-new-task(new-task shift)
  (let((new-task-position nil)
       (new-task-duration (task-time new-task))
       (tasks (shift-tasks shift))
       (current-shift-duration (shift-time-used shift)))
    (if (and (not (calc-intersection new-task tasks))
             (< (+ current-shift-duration new-task-duration) max-shift))
        (if (not (shift-meal-taken shift))
            (if (>= (+ current-shift-duration new-task-duration) max-time-til-lunch)
                (setf (shift-meal-taken shift) 'T
                       (shift-time-used shift) (+ current-shift-duration eat-duration))
              (setf (shift-tasks shift) (insert-task new-task-position new-task tasks)
                    (shift-time-used shift) (+ current-shift-duration new-task-duration)))))
    (return-from check-new-task shift)))
  ;insert in new position
  ;increment time used
  ;calc empty space

(defun sucessors (state))

(defun heuristic (state))

(defun faz-afetacao (tasks)
  (let((initial-state (make-state :shifts '()
                                  :to-assign-tasks tasks)))))
  ; (problem (cria-problema (initial-state
   ;                         (list 'sucessors)
    ;                        :objetivo? (eq (state-to-assign-tasks initial-state) '())
    ;                        :heuristica 'heuristic))))
