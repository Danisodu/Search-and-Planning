;;;; Author(s): Group 8

;;;;IMPORTS


;;;; CONSTANTS
(defconstant max-shift 480)
(defconstant max-time-til-lunch 240)
(defconstant drive-duration 40)
(defconstant eat-duration 40)


;;;; STRUCTS
(defstruct shift
  tasks
  time-used
  empty-space
  meal-taken)

(defstruct state
  shifts
  to-assign-tasks)


;;;; FUNCS
(defun create-shift()
   (make-shift :tasks '()
               :time-used 0
               :empty-space 0
               :meal-taken nil))

(defun task-time(task)
  (- (nth 3 task) 
     (nth 2 task)))

(defun shift-time(shift)
  (let ((first-task (car (shift-tasks shift)))
        (last-task (nth (1- (length (shift-tasks shift))) 
                        (shift-tasks shift))))
    (+ (nth 2 first-task) 
       (nth 3 last-task))))

(defun insert-task-in-position(position task tasks)
  (return-from insert-task-in-position (cons (cons (subseq tasks 
                                                           0 
                                                           position) task)
                                             (nthcdr position tasks))))

(defun add-task-to-shift(position task shift)
  (setf (shift-tasks shift) (insert-task-in-position position
                                                     task 
                                                     (shift-tasks shift))
        (shift-time-used shift) (+ (task-time task) 
                                   (shift-time-used shift)))
  (return-from add-task-to-shift shift))

(defun add-drive-duration?(origin destination end-time)
  (if (/= origin destination)
      (setf end-time (+ end-time drive-duration)))
  (return-from add-drive-duration? end-time))

;;;empty-space-two-tasks: task x task -> integer
;; Calculates the IDLE time between two tasks			 
(defun empty-space-two-tasks(t1 t2)
	(- (nth 2 t2) (nth 3 t1) )
)

;;;list can't be empty
(defun calc-empty-spaces(new-task tasks)
  (let ((empty-spaces (list (list (nth 0 (car tasks)) (nth 0 (car tasks) 0 0))))
        (last-task (nth (1- (length tasks)) tasks))
        (current)
        (next)
        (total 0))
    (loop for i from 0 to (- (length tasks) 2) do
          (setf current (nth i tasks)
                next (nth (1+ i) tasks))
          (setf empty-spaces (cons (list current
                                         next) 
                                   empty-spaces)))
    (cons (list (nth 1 last-task)
                (list (nth 1 last-task) (nth 1 last-task) max-shift max-shift))
          empty-spaces)))

(defun is-intersected(new-task other-task1 other-task2)
  (let ((new-task-start-time (nth 2 new-task))
        (new-task-end-time (nth 3 new-task))
        (new-task-origin (nth 0 new-task))
        (new-task-destination (nth 1 new-task))
        (other1-task-end-time (nth 3 other-task1))
        (other1-task-destination (nth 1 other-task1))
        (other2-task-origin (nth 0 other-task2)))
    (setf other1-task-end-time (add-drive-duration? new-task-origin
                                                    other1-task-destination
                                                    other1-task-end-time)
          new-task-end-time (add-drive-duration? other2-task-origin
                                                 new-task-destination
                                                 new-task-end-time))
      (and (> other1-task-end-time new-task-start-time)
           (> new-task-end-time other2-task-start-time))))

(defun find-position (new-task tasks)
  (let ((position nil)
        (empty-spaces (calc-empty-spaces new-task tasks)))
    (loop for empty-space in empty-spaces and position from 0 do
          (multiple-value-bind(intersected) (is-intersected new-task
                                                            (nth 0 empty-space)
                                                            (nth 1 empty-space))
            (if (not intersected)
                (setf position i)
              (progn 
                (setf position nil)
                (return)))))
  (return-from find-position position)))

;0 = tasks doesn't fit
;1 = fits and meal-taken doesn't change
;2 = fits and meal-taken does change
(defun check-new-task(new-task shift)
  (let ((correct 1)
        (new-task-duration (task-time new-task))
        (current-shift-duration (shift-time-used shift)))
    (if (< (+ current-shift-duration new-task-duration) max-shift)
        (if (not (shift-meal-taken shift))
            ;confirmar tempo de conducao
            (if (>= (+ current-shift-duration new-task-duration) max-time-til-lunch)
                (setf correct 2)))
      (setf correct 0))
    (return-from check-new-task correct)))

;check if there's any shift were the constraints are verified
;for any of those that verify them, the possible positions are
(defun sucessors (state)
  (let ((next-task (pop (state-to-assign-tasks state)))
        (shifts (state-to-assign-tasks state))
        (correct 0))
    (loop for shift in shifts do
          (progn
            (setf correct (check-new-task next-task shift))))))
            ;(if (and (eq correct 1)
             ;        (/= (find-possible-positions task shift) nil))))))  

;(setf shift (add-task-to-shift new-task-position
;                                             new-task
;                                            shift)))))


(defun heuristic (state))

(defun faz-afetacao (tasks)
  (let((initial-state (make-state :shifts '()
                                  :to-assign-tasks tasks)))))
  ; (problem (cria-problema (initial-state
   ;                         (list 'sucessors)
    ;                        :objetivo? (eq (state-to-assign-tasks initial-state) '())
    ;                        :heuristica 'heuristic))))
